/// <reference types="lodash" />
import fp from 'lodash/fp';
import { F } from 'ts-toolbelt';
declare type Tthen = F.Curry<(fn: (response: any) => any, thenable: Promise<unknown>) => Promise<any>>;
declare type Totherwise = F.Curry<(failureHandler: (error: Error | any) => never | any, thenable: Promise<Error | any>) => Promise<never | any>>;
declare type Tfinally = F.Curry<(callback: (...args: any[]) => any, thenable: Promise<any>) => Promise<any>>;
declare type Tternary = F.Curry<(<T>(evaluator: (arg: T) => boolean | any, trueHandler: (arg: T) => any | any, falseHandler: (arg: T) => any | any, arg: T) => any)>;
declare type TifT = F.Curry<(<T, R>(evaluator: (arg: T) => boolean | boolean, trueHandler: (arg: T) => R | R, arg: T) => T | R)>;
declare type TifF = F.Curry<(<T, R>(evaluator: (arg: T) => boolean | boolean, falseHandler: (arg: T) => R | R, arg: T) => T | R)>;
declare type TinstanceOf = F.Curry<(<T>(t: any, arg: T) => boolean)>;
declare type TmapAsync = F.Curry<(<T, K extends keyof T, R>(asyncMapper: (arg: T[K], key: K) => Promise<R>, collection: T) => Promise<R[]>)>;
declare type TfilterAsync = F.Curry<(<T, K extends keyof T, R>(asyncFilter: (arg: T[K], key: K) => Promise<boolean>, collection: T) => Promise<R[]>)>;
declare type TfindAsync = F.Curry<(<T, K extends keyof T, R>(asyncFilter: (arg: T[K], key: K) => Promise<boolean>, collection: T) => Promise<R>)>;
declare type TreduceAsync = F.Curry<(<T, K extends keyof T>(asyncFn: (acc: unknown, arg: T[K], key: K) => Promise<unknown>, initAcc: Promise<unknown> | unknown, collection: T) => Promise<unknown>)>;
declare type Tkey = F.Curry<(obj: object, value: unknown) => string>;
declare type TtransformObjectKey = F.Curry<(transformFn: (orignStr: string) => string, obj: Record<string, unknown>) => Record<string, unknown>>;
declare type TnotIncludes = F.Curry<(arg: unknown, targetArray: unknown[]) => boolean>;
declare type TnotEquals = F.Curry<(a: unknown, b: unknown) => boolean>;
declare type TremoveByIndex = F.Curry<(<TResult>(index: number | string, targetArray: TResult[]) => TResult[])>;
declare type Tprepend = F.Curry<(array: unknown[], value: unknown | unknown[]) => unknown[]>;
declare type TmapWithKey = F.Curry<(<T, K extends keyof T, R>(iteratee: (value: T[K], key: K) => R, collection: T) => R[])>;
declare type TforEachWithKey = F.Curry<(<T, K extends keyof T, R>(iteratee: (value: T[K], key: K) => R, collection: T) => R[])>;
declare type TreduceWithKey = F.Curry<(<T, K extends keyof T, R>(iteratee: (acc: R, value: T[K], key: K) => R, acc: R, collection: T) => R)>;
declare const _default: {
    mapAsync: TmapAsync;
    filterAsync: TfilterAsync;
    reduceAsync: TreduceAsync;
    findAsync: TfindAsync;
    forEachAsync: (...args: any[]) => any;
    promisify: (a: any, ...args: any[]) => Promise<any>;
    then: Tthen;
    andThen: Tthen;
    otherwise: Totherwise;
    catch: Totherwise;
    finally: Tfinally;
    isPromise: <T>(x: T) => boolean;
    isNotEmpty: (a: any) => boolean;
    isNotNil: (arg: unknown) => boolean;
    isJson: (jsonStr: string) => boolean;
    notEquals: TnotEquals;
    isNotEqual: TnotEquals;
    isVal: (arg: unknown) => boolean;
    isPrimitive: (arg: unknown) => boolean;
    isRef: (arg: unknown) => boolean;
    isReference: (arg: unknown) => boolean;
    not: <T_1>(x: T_1) => boolean;
    notIncludes: TnotIncludes;
    toBool: (arg: any) => boolean;
    deepFreeze: (obj: Record<string, unknown>) => Record<string, unknown>;
    key: Tkey;
    keyByVal: Tkey;
    transformObjectKey: TtransformObjectKey;
    toCamelcase: F.Curry<(obj: Record<string, unknown>) => Record<string, unknown>>;
    toCamelKey: F.Curry<(obj: Record<string, unknown>) => Record<string, unknown>>;
    toSnakecase: F.Curry<(obj: Record<string, unknown>) => Record<string, unknown>>;
    toSnakeKey: F.Curry<(obj: Record<string, unknown>) => Record<string, unknown>>;
    toPascalcase: F.Curry<(obj: Record<string, unknown>) => Record<string, unknown>>;
    pascalCase: (str: string) => string;
    isDatetimeString: (dateStr: string) => boolean;
    ap: import("lodash").CurriedFunction2<unknown, Function, any>;
    instanceOf: TinstanceOf;
    ternary: Tternary;
    ifT: TifT;
    ifF: TifF;
    removeByIndex: TremoveByIndex;
    removeByIdx: TremoveByIndex;
    removeLast: (target: string | unknown[]) => string | any[];
    append: fp.LodashConcat;
    prepend: Tprepend;
    mapWithKey: TmapWithKey;
    mapWithIdx: TmapWithKey;
    forEachWithKey: TforEachWithKey;
    forEachWithIdx: TforEachWithKey;
    reduceWithKey: TreduceWithKey;
    reduceWithIdx: TreduceWithKey;
    isFalsy: (arg: unknown) => boolean;
    isTruthy: (arg: unknown) => boolean;
    getOr: import("lodash").CurriedFunction3<unknown, string, unknown, any>;
    delayAsync: (ms: number) => Promise<void>;
};
export default _default;

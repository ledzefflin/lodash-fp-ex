import r from"lodash/fp";function e(r,e,n,t,i,c,u){try{var o=r[c](u),s=o.value}catch(r){return void n(r)}o.done?e(s):Promise.resolve(s).then(t,i)}function n(r){return function(){var n=this,t=arguments;return new Promise((function(i,c){var u=r.apply(n,t);function o(r){e(u,i,c,o,s,"next",r)}function s(r){e(u,i,c,o,s,"throw",r)}o(void 0)}))}}const t=e=>r.isFunction(r.get("then",e))&&r.isFunction(r.get("catch",e)),i=(e,...n)=>r.cond([[r.isFunction,()=>((r,...e)=>new Promise(((n,t)=>{try{n(r(...e))}catch(r){t(r)}})))(e,...n)],[t,r.identity],[r.T,r=>Promise.resolve(r)]])(e),c=r=>t(r)?r.then((r=>c(r))):r,u=r.curry(((r,e)=>i(e).then(c(r)))),o=r.curry(((r,e)=>i(e).catch(c(r)))),s=r.curry(((r,e)=>i(e).finally(c(r)))),a=r=>!r,p=r.pipe(r.isEmpty,a),y=e=>r.cond([[r.equals("true"),r.T],[r.equals("false"),r.F],[r.T,r=>!!r]])(e),l=r.curry(((e,n,t)=>t?r.isFunction(e)?e():e:r.isFunction(n)?n():n)),f=r.curry(((r,e)=>e instanceof r)),d=r.pipe(r.camelCase,r.upperFirst),m=r.curry(function(){var e=n((function*(e,t){return r.pipe(r.flatMapDeep(r.pipe(e,i)),function(){var r=n((function*(r){return Promise.all(r)}));return function(e){return r.apply(this,arguments)}}())(t)}));return function(r,n){return e.apply(this,arguments)}}()),h=r.curry(function(){var e=n((function*(e,t){const i=r.pipe(m(function(){var r=n((function*(r){return!!(yield e(r))&&r}));return function(e){return r.apply(this,arguments)}}()),u(r.filter(r.pipe(r.equals(!1),a))));return yield i(t)}));return function(r,n){return e.apply(this,arguments)}}()),v=r.curry(function(){var e=n((function*(e,n){const t=r.pipe(m(e),u(r.indexOf(!0)),u((e=>r.get(`[${e}]`,n))),o(r.always(void 0)));return yield t(n)}));return function(r,n){return e.apply(this,arguments)}}()),F=r.curry(((e,n,t)=>{const i=Promise.resolve(n);return r.reduce(e,i,t)})),w=r.curry(((e,n)=>r.pipe(r.invert,r.get(e))(n))),N=e=>r.pipe(Object.freeze,r.forOwn((e=>!r.isPlainObject(e)&&!r.isFunction(e)||Object.isFrozen(e)?e:N(e))))(e),O=r.curry(((e,n)=>r.isObject(n)||r.isArray(n)?(n=>{const t=n=>r.pipe(r.entries,r.reduce(((n,[i,c])=>{const u=r.cond([[r.isPlainObject,t],[r.isArray,e=>r.map(u,e)],[r.T,r.identity]]);return n[e(i)]=u(c),n}),{}))(n);return t(n)})(n):n)),P=O(r.camelCase),A=O(r.snakeCase),b=r.curry(((r,e)=>e(r))),g=r.pipe(r.isNil,a),E=r.curry(((e,n,t)=>{if(r.every(r.isFunction,[e,n]))return r.pipe(e,y)(t)?n(t):t;throw new Error("invalid parameter(s)")})),j=r.curry(((e,n,t)=>{if(r.every(r.isFunction,[e,n]))return r.pipe(e,y)(t)?t:n(t);throw new Error("invalid parameter(s)")})),q=r.curry(((e,n)=>r.pipe(r.includes,b(n),a)(e))),C=r.curry(((e,n)=>r.pipe(r.equals(e),r.not)(n))),D=r.curry(((e,n)=>{if(r.isArray(n)){const t=r.cloneDeep(n);return t.splice(r.toNumber(e),1),t}return n})),T=r.concat,x=r.curry(((e,n)=>r.isArray(n)?r.concat(n,e):r.concat([n],e))),S=r.curry(((r,e)=>e.map(r))),k=r.curry(((r,e,n)=>n.reduce(r,e)));module.exports={mapAsync:m,filterAsync:h,reduceAsync:F,findAsync:v,promisify:i,then:u,otherwise:o,finally:s,isPromise:t,isNotEmpty:p,isNotNil:g,isJson:e=>{const n=r.pipe(r.attempt,r.isError);return r.isString(e)&&!n((()=>JSON.parse(e)))},notEquals:C,not:a,notIncludes:q,toBool:y,deepFreeze:N,key:w,pascalCase:d,toCamelcase:P,toSnakecase:A,isDateString:r=>isNaN(r)&&!isNaN(Date.parse(r)),ap:b,instanceOf:f,ternary:l,ifT:E,ifF:j,removeByIndex:D,removeLast:e=>{const n=r.cloneDeep(e);return n.pop(),n},append:T,prepend:x,mapWithKey:S,reduceWithKey:k};
//# sourceMappingURL=lodash-fp-ex.es.js.map

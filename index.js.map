{"version":3,"file":"index.js","sources":["lib/index.js"],"sourcesContent":["import fp from 'lodash/fp';\r\n\r\n/**\r\n * 대상 인자가 promise(thenable)인지 여부 조회\r\n *\r\n * @param {any} x 조회 대상\r\n * @return {boolean} 대상 인자가 promise(thenable)인지 여부\r\n */\r\nconst isPromise = (x) => fp.isFunction(fp.get('then', x)) && fp.isFunction(fp.get('catch', x));\r\n\r\n/**\r\n * 대상 함수를 promise로 lift\r\n *\r\n * @param {function} fn 대상 합수\r\n * @param  {...any} args 함수 인자 목록\r\n * @returns {Promise<any>} Promise로 lift된 Promise 객체\r\n */\r\nconst fnPromisify = (fn, ...args) => {\r\n  return new Promise((resolve, reject) => {\r\n    try {\r\n      resolve(fn(...args));\r\n    } catch (e) {\r\n      reject(e);\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * 대상 인자를 promise로 wrapping (lift)\r\n *\r\n * @param {any} a 대상 인자\r\n * @param {...any} args 대상 인자 a가 함수인 경우, 함수의 인자목록\r\n * @return {Promise<any>} Promise로 lift된 Promise 객채\r\n */\r\nconst promisify = (a, ...args) => {\r\n  const cond = fp.cond([\r\n    [fp.isFunction, () => fnPromisify(a, ...args)],\r\n    [isPromise, fp.identity],\r\n    [fp.T, (a) => Promise.resolve(a)]\r\n  ]);\r\n  const result = cond(a);\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * promise가 또다른 promise를 resolve하는 경우, promise의 중첩을 제거하기 위한 helper 함수\r\n *\r\n * @param {Promise<any>} thenable Promise 객체\r\n * @return {Promise<any>} 중첩 제거된 Promise 객체\r\n */\r\nconst flatPromise = (thenable) =>\r\n  isPromise(thenable) ? thenable.then((x) => flatPromise(x)) : thenable;\r\n\r\n/**\r\n * lodash 형태의 promise then\r\n *\r\n * @param {(response) => any} fn 응답값 처리 callback\r\n * @param {Promise<any>} thenable resolve 대상 Promise 객체\r\n * @returns {Promise<any>} fullfilled 상태의 Promise 객체\r\n */\r\nconst then = fp.curry((fn, thenable) => promisify(thenable).then(flatPromise(fn)));\r\n\r\n/**\r\n * lodash 형태의 promise catch\r\n *\r\n * @param {(error) => never} fn error 처리 callback\r\n * @param {Promise<error>} thenable error를 resolve 하는 promise\r\n * @return {Promise<never>} error 상태의 Promise 객체\r\n */\r\nconst otherwise = fp.curry((fn, thenable) => promisify(thenable).catch(flatPromise(fn)));\r\n\r\n/**\r\n * lodash 형태의 promise finally\r\n *\r\n * @param {() => any} fn Promise 상태와 무관하게 실행되는 callback\r\n * @param {Promise<any>} thenable Promise 객체\r\n * @return {void} 반환값 없음\r\n */\r\nconst _finally = fp.curry((fn, thenable) => promisify(thenable).finally(flatPromise(fn)));\r\n\r\n/**\r\n * invert boolean\r\n * @param {any} x 대상\r\n * @return {boolean} not 연산된 값\r\n */\r\nconst not = (x) => !x;\r\n\r\n/**\r\n * 대상이 비어있지 않은지 여부\r\n * (주의: 숫자타입은 항상 true를 반환)\r\n *\r\n * @param {any} a 대상\r\n * @returns {boolean} 비어 있는지 여부\r\n */\r\nconst isNotEmpty = fp.pipe(fp.isEmpty, not);\r\n\r\n/**\r\n * 대상 인자를 boolean 타입으로 변환\\\r\n *\r\n * @param {any} a 대상\r\n * @returns {boolean} 변환된 boolean 타입 값\r\n */\r\nconst toBool = (a) => !!a;\r\n\r\n/**\r\n * 삼항식 helper 함수\\\r\n * (isTrue가 true면 t(실행)반환, false면 f(실행)반환)\r\n *\r\n * @param {function} evaluator 대상인자가 true 인지여부 조회 함수 또는 boolean을 반환하는 함수\r\n * @param {function} trueHandler evaluator가 true를 반환하면,  실행되는 대상인자를 인자로 갖는 함수\r\n * @param {function} falseHandler evaluator가 false를 반환하면, 실행되는 대상인자를 인자로 갖는 함수\r\n * @param {function|any} a 대상인자\r\n * @returns {any} handler의 결과값\r\n */\r\nconst ternary = fp.curry((evaluator, trueHandler, falseHandler, a) => {\r\n  const executor = fp.curry((t, f, a, isTrue) => {\r\n    const result = isTrue ? (fp.isFunction(t) ? t(a) : t) : fp.isFunction(f) ? f(a) : f;\r\n    return result;\r\n  });\r\n  const getEvaluator = (fn) => (fp.isNil(fn) ? fp.identity : fn);\r\n  const result = executor(trueHandler, falseHandler, a, getEvaluator(evaluator)(a));\r\n\r\n  return result;\r\n});\r\n\r\n/**\r\n * a인자가 t타입인지 여부 조회\r\n * @param {any} t 조회 대상 type\r\n * @param {any} a 조회 대상\r\n * @returns {boolean} a인자가 t타입인지 여부\r\n */\r\nconst instanceOf = fp.curry((t, a) => a instanceof t);\r\n\r\n/**\r\n * 대상 문자열을 pascalcase 문자열로 변환\r\n * @param {string} a 대상 문자열\r\n * @returns {string} pascal case로 변환된 문자열\r\n */\r\nconst pascalCase = fp.pipe(fp.camelCase, fp.upperFirst);\r\n\r\n/**\r\n * (collection) fp.map의 비동기 함수\\\r\n * mapper 함수로 비동기 함수를 받아서 처리해준다.\r\n *\r\n * @param {(a) => Promise<any>} asyncMapper 비동기 mapper\r\n * @param {object|any[]} collection 대상 object 또는 array\r\n * @returns {Promise<any[]>} 결과 array를 resolve 하는 promise\r\n */\r\nconst mapAsync = fp.curry(async (asyncMapper, collection) => {\r\n  const composer = fp.pipe(\r\n    fp.flatMapDeep(fp.pipe(asyncMapper, promisify)),\r\n    async (a) => await Promise.all(a)\r\n  );\r\n  const result = await composer(collection);\r\n\r\n  return result;\r\n});\r\n\r\n/**\r\n * (collection) fp.filter의 비동기 함수\\\r\n * 필터함수로 비동기 함수를 받아서 처리해준다.\r\n *\r\n * @param {(a) => Promise<bool>} asyncFilter 비동기 필터\r\n * @param {object|any[]} collection 대상 object 또는 array\r\n * @returns {Promise<any[]>} 결과 array를 resolve하는 promise\r\n */\r\nconst filterAsync = fp.curry(async (asyncFilter, arr) => {\r\n  const composer = fp.pipe(\r\n    mapAsync(async (item) => ((await asyncFilter(item)) ? item : false)),\r\n    then(fp.filter(fp.pipe(fp.equals(false), not)))\r\n  );\r\n  const result = await composer(arr);\r\n\r\n  return result;\r\n});\r\n/**\r\n * (collection) fp.find의 비동기 함수\r\n * @param {(a) => Promise<bool>} asyncFn 비동기 필터\r\n * @param {object|any[]} collection 대상 object 또는 array\r\n * @returns {Promise<any>} 필터된 단일 결과를 resolve하는 promise\r\n */\r\nconst findAsync = fp.curry(async (asyncFn, arr) => {\r\n  const composer = fp.pipe(\r\n    mapAsync(asyncFn),\r\n    then(fp.indexOf(true)),\r\n    then((idx) => fp.get(`[${idx}]`, arr)),\r\n    otherwise(fp.always(undefined))\r\n  );\r\n  const result = await composer(arr);\r\n\r\n  return result;\r\n});\r\n\r\n/**\r\n * asyncFn의 시작은 await accPromise가 되어야 한다.\\\r\n * 순차적으로 실행된다.\\\r\n * (ex 300ms이 걸리는 5개의 promise가 있다면, 최소 1500ms+alpah의 시간이 소요된다.\\\r\n * 상기의 mapAsync의 경우 300+alpah의 시간만 소요된다.(Promise.all과 Promise.resolve의 차이))\r\n *\r\n * @param {(acc, v) => Promise<any>} asyncFn 비동기 iterator\r\n * @param {Promise<any>} initAcc 초기 누적기를 반환하는 promise\r\n * @param {object|any[]} dest 대상 객체 또는 배열\r\n * @returns {Promise<any>} 결과 Promise\r\n */\r\nconst reduceAsync = fp.curry((asyncFn, initAcc, dest) => {\r\n  const initAccPromise = Promise.resolve(initAcc);\r\n  const result = fp.reduce(asyncFn, initAccPromise, dest);\r\n  return result;\r\n});\r\n\r\n/**\r\n * 비동기 forEach\r\n * 실행함수로 비동기 함수를 받아서 처리해준다\r\n * 순차실행\r\n *\r\n * @param {(a) => Promise<any>} cb 비동기 iterator\r\n * @param {object|any[]} collection 대상 객체 또는 배열\r\n * @returns {Promise<any[]>} 결과 Promise\r\n */\r\nconst forEachAsync = fp.curry(async (cb, collection) => {\r\n  const loopResults = [];\r\n  const iterator = fp.entries(collection);\r\n\r\n  for (const e of iterator) {\r\n    loopResults.push(await cb(e[1], e[0]));\r\n  }\r\n\r\n  return loopResults;\r\n});\r\n\r\n/**\r\n * value로 object key 조회\r\n *\r\n * @param {object} a 대상 객체\r\n * @param {string} v 조회 대상 key (속성명)\r\n * @returns {any} 속성명에 해당하는 값\r\n */\r\nconst key = fp.curry((a, v) => {\r\n  const composer = fp.pipe(\r\n    fp.entries,\r\n    fp.find(([k, val]) => fp.equals(v, val)),\r\n    fp.head\r\n  );\r\n  const result = composer(a);\r\n\r\n  return result;\r\n});\r\n\r\n/**\r\n * 대상 문자열이 json형식 문자열인지 여부 조회\r\n *\r\n * @param {string} a 조회 대상 문자열\r\n * @returns {boolean} json 문자열인지 여부\r\n */\r\nconst isJson = (a) => {\r\n  const composer = fp.pipe(fp.attempt, fp.isError);\r\n  return fp.isString(a) && !composer(() => JSON.parse(a));\r\n};\r\n\r\n/**\r\n * shallow freeze 보완\r\n * (대상 object의 refence 타입의 properties까지 object.freeze 처리)\r\n * @param {object} obj 대상 객체\r\n * @returns {object} frozen 처리된 객체\r\n */\r\nconst deepFreeze = (obj) => {\r\n  const freezeRecursively = (v) => (isRef(v) && !Object.isFrozen(v) ? deepFreeze(v) : v);\r\n  const composer = fp.pipe(Object.freeze, fp.forOwn(freezeRecursively));\r\n  const result = composer(obj);\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * 대상 객체의 속성명을 transformFn의 결과값으로 변환\r\n *\r\n * @param {(a) => string} transformFn 변환함수\r\n * @param {object} dest 대상 객체\r\n * @returns {object} 속성명이 변환된 객체\r\n */\r\nconst transformObjectKey = fp.curry((transformFn, dest) => {\r\n  const convertRecursively = (dest) => {\r\n    const convertTo = (o) => {\r\n      const composer = fp.pipe(\r\n        fp.entries,\r\n        fp.reduce((acc, [k, v]) => {\r\n          const cond = fp.cond([\r\n            [fp.isPlainObject, convertTo],\r\n            [fp.isArray, (v) => v.map(cond)],\r\n            [fp.T, (a) => a]\r\n          ]);\r\n          const transformedKey = transformFn(k);\r\n          if (!fp.has(transformedKey, acc)) {\r\n            acc[transformedKey] = cond(v);\r\n            return acc;\r\n          } else {\r\n            throw new Error(\r\n              `${transformedKey} already exist. duplicated property name is not supported.`\r\n            );\r\n          }\r\n        }, {})\r\n      );\r\n      const result = composer(o);\r\n      return result;\r\n    };\r\n    const result = convertTo(dest);\r\n    return result;\r\n  };\r\n\r\n  const result = fp.isObject(dest) || fp.isArray(dest) ? convertRecursively(dest) : dest;\r\n\r\n  return result;\r\n});\r\n\r\n/**\r\n * 대상 object의 property key문자열을 camelcase 문자열로 변환\r\n *\r\n * @param {object} a 대상 객체\r\n * @returns {object} 속성명이 camel case로 변환된 객체\r\n */\r\nconst toCamelcase = transformObjectKey(fp.camelCase);\r\n\r\n/**\r\n * 대상 object의 property key문자열을 snakecase 문자열로 변환\r\n *\r\n * @param {object} a 대상 객체\r\n * @returns {object} 속성명이 snake case로 변환된 객체\r\n */\r\nconst toSnakecase = transformObjectKey(fp.snakeCase);\r\nconst toPascalcase = transformObjectKey(pascalCase);\r\n\r\n/**\r\n * date형식 문자열 여부 조회\r\n * @param {string} str date형식 문자열\r\n * @returns {boolean} date형식 문자열 여부\r\n */\r\nconst isDatetimeString = (str) => isNaN(str) && !isNaN(Date.parse(str));\r\n/**\r\n * applicative functor pattern 구현체\r\n * (주로 fp.pipe함수에서 함수의 인자 순서를 변경하기 위해 사용)\r\n *\r\n * @param {any} a 대입 인자\r\n * @param {function} curried currying된 함수\r\n * @returns {any} 결과값\r\n */\r\nconst ap = fp.curry((a, curried) => curried(a));\r\n\r\n/**\r\n * 대상 인자가 undefined 또는 null이 아닌지 여부 조회\r\n *\r\n * @param {any} a 대상인자\r\n * @returns {boolean} 대상 인자가 undefined 또는 null이 아닌지 여부\r\n */\r\nconst isNotNil = fp.pipe(fp.isNil, not);\r\n\r\n/**\r\n * a인자를 인자로, evaluator함수 실행,\r\n * true면 trueHandler에 a인자 대입\r\n * false면 a 반환\r\n *\r\n * @param {(a) => boolean} evaluator a를 인자로 하는 평가함수\r\n * @param {(a) => any} trueHandler evaluator의 결과가 true인 경우, a를 인자로 실행되는 callback\r\n * @param {any} a 대상 인자\r\n * @returns {any} evaluator가 true를 반환하는 경우, trueHandler의 결과값, false인 경우 a 반환\r\n */\r\nconst ifT = fp.curry((evaluator, trueHandler, a) => {\r\n  const isValidParams = fp.every(fp.isFunction, [evaluator, trueHandler]);\r\n\r\n  if (isValidParams) {\r\n    return fp.pipe(evaluator, fp.equals(true))(a) ? trueHandler(a) : a;\r\n  } else {\r\n    throw new Error('invalid parameter(s)');\r\n  }\r\n});\r\n\r\n/**\r\n * a인자를 인자로, evaluator함수 실행,\r\n * false면 falseHandler에 a인자 대입\r\n * true면 a 반환\r\n *\r\n * @param {(a) => boolean} evaluator a를 인자로 하는 평가함수\r\n * @param {(a) => any} falseHandler evaluator의 결과가 false인 경우, a를 인자로 실행되는 callback\r\n * @param {any} a 대상 인자\r\n * @returns {any} evaluator가 false를 반환하는 경우, falseHandler의 결과값, true경우 a 반환\r\n */\r\nconst ifF = fp.curry((evaluator, falseHandler, a) => {\r\n  const isValidParams = fp.every(fp.isFunction, [evaluator, falseHandler]);\r\n\r\n  if (isValidParams) {\r\n    return fp.pipe(evaluator, fp.equals(false))(a) ? falseHandler(a) : a;\r\n  } else {\r\n    throw new Error('invalid parameter(s)');\r\n  }\r\n});\r\n\r\n/**\r\n * arr인자 배열에 a인자가 포함되지 않았는지 여부 조회\r\n * @param {any} a 대상 인자\r\n * @param {any[]} arr 대상 배열\r\n * @returns {boolean} arr 배열에 a인자가 포함되지 않았는지 여부\r\n */\r\nconst notIncludes = fp.curry((a, arr) => {\r\n  const composer = fp.pipe(fp.includes, ap(arr), not);\r\n  const result = composer(a);\r\n\r\n  return result;\r\n});\r\n\r\n/**\r\n * a인자와 b인자가 다른지 여부 (deep equal) 조회\r\n * @param {any} a 비교 인자\r\n * @param {any} b 비교 인자\r\n * @returns {boolean} a인자와 b인자가 다른지 여부 (deep equal)\r\n */\r\nconst notEquals = fp.curry((a, b) => fp.pipe(fp.equals(a), not)(b));\r\n\r\n/**\r\n * arr인자의 idx인자의 index에 해당하는 요소 제거\r\n * @param {number|string} idx numeric 타입 색인값\r\n * @param {any[]} arr 대상 배열\r\n * @returns {any[]} index에 해당하는 요소 제거된 배열\r\n */\r\nconst removeByIndex = fp.curry((idx, arr) => {\r\n  if (fp.isArray(arr)) {\r\n    const cloned = fp.cloneDeep(arr);\r\n    cloned.splice(fp.toNumber(idx), 1);\r\n\r\n    return cloned;\r\n  }\r\n  return arr;\r\n});\r\n\r\n/**\r\n * 인자의 마지막 요소 제거 (immutable)\r\n *\r\n * @param {string|any[]} arr 문자열 또는 배열의 마지막 요소 제거\r\n * @returns 마지막 요소 제거된 인자\r\n */\r\nconst removeLast = (a) => {\r\n  const nextA = fp.cloneDeep(a);\r\n  if (fp.isArray(a)) {\r\n    nextA.pop();\r\n  }\r\n  if (fp.isString(a)) {\r\n    return nextA.substring(0, fp.size(a) - 1);\r\n  }\r\n  return nextA;\r\n};\r\n\r\n/**\r\n * fp.concat alias\r\n *\r\n * @param {any[]} array 병합대상 배열\r\n * @param {any|any[]} a 병합 인자\r\n * @returns {any[]} 병합된 배열\r\n */\r\nconst append = fp.concat;\r\n\r\n/**\r\n * array 인자의 (index상)앞쪽에 value인자를 추가\r\n *\r\n * @param {any[]} array 병합대상 배열\r\n * @param {any|any[]} value 병합 인자\r\n * @returns {any[]} 병합된 배열\r\n */\r\nconst prepend = fp.curry((array, value) =>\r\n  fp.isArray(value) ? fp.concat(value, array) : fp.concat([value], array)\r\n);\r\n\r\n/**\r\n * key(index)를 포함한 fp.map\r\n * @param {(v, k) => any} f value, key(또는 index)를 인자로 갖는 callback\r\n * @param {object|any[]} a 대상 collection\r\n * @returns {any[]} 결과 배열\r\n */\r\nconst mapWithKey = fp.curry((f, a) => fp.map.convert({ cap: false })(f, a));\r\n\r\n/**\r\n * key(index)를 포함한 fp.forEach\r\n * @param {(v, k) => any} f value, key(또는 index)를 인자로 갖는 callback\r\n * @param {object|any[]} a 대상 collection\r\n * @returns {void} 반환값 없음\r\n */\r\nconst forEachWithKey = fp.curry((f, a) => fp.forEach.convert({ cap: false })(f, a));\r\n\r\n/**\r\n * key(index)를 포함한 reduce\r\n *\r\n * @param {(acc, v, k) => any} f accumulator, value, key(또는 index)를 인자로 갖는 callback\r\n * @param {any} acc 누적기\r\n * @param {object|any[]} 대상 collection\r\n * @returns {any} 누적기\r\n */\r\nconst reduceWithKey = fp.curry((f, acc, a) => fp.reduce.convert({ cap: false })(f, acc, a));\r\n\r\n/**\r\n * 원시 타입(primitive) 인지 여부 조회\r\n * null, undefined, Boolean, Number, String\r\n *\r\n * @param {any} a 조회 대상\r\n * @returns {boolean} 원시 타입(primitive) 인지 여부\r\n */\r\nconst isVal = (a) => fp.isNil(a) || fp.isBoolean(a) || fp.isNumber(a) || fp.isString(a);\r\n\r\n/**\r\n * 참조 타입(reference) 인지 여부 조회\r\n * Array, Object, Function\r\n *\r\n * @param {any} a 조회 대상\r\n * @returns {boolean} 참조 타입(reference) 인지 여부\r\n */\r\nconst isRef = fp.pipe(isVal, not);\r\n\r\n/**\r\n * falsy 타입(0, -0, NaN, false, '')인지 여부 조회\r\n * @param {any} a 조회 대상\r\n * @returns {boolean} falsy 타입(0, -0, NaN, false, '')인지 여부\r\n */\r\nconst isFalsy = (a) => {\r\n  return fp.isNil(a) || fp.some(fp.equals(a), [0, -0, NaN, false, '']);\r\n};\r\n\r\n/**\r\n * truthy 타입 인지 여부 조회\r\n * (falsy타입(0, -0, NaN, false, '')이 아니면 truthy 타입)\r\n * @param {any} a 조회 대상\r\n * @returns {boolean} truthy 타입 인지 여부\r\n */\r\nconst isTruthy = (a) => !isFalsy(a);\r\n\r\n/**\r\n * fp.getOr override\r\n *\r\n * fp.getOr의 반환값이 null인 경우, 기본값 반환되게 수정한 버전\r\n * circular dependency 때문에 closure로 작성\r\n */\r\nconst getOr = (({ curry, getOr }) => {\r\n  const _getOr = curry((defaultValue, path, target) => {\r\n    const val = fp.get(path, target);\r\n    return fp.isNil(val) ? defaultValue : val;\r\n  });\r\n  return _getOr;\r\n})(fp);\r\n\r\nexport default {\r\n  mapAsync,\r\n  filterAsync,\r\n  reduceAsync,\r\n  findAsync,\r\n  forEachAsync,\r\n  promisify,\r\n  then,\r\n  andThen: then,\r\n  otherwise,\r\n  catch: otherwise,\r\n  finally: _finally,\r\n\r\n  isPromise,\r\n  isNotEmpty,\r\n  isNotNil,\r\n  isJson,\r\n  notEquals,\r\n  isNotEqual: notEquals,\r\n  isVal,\r\n  isPrimitive: isVal,\r\n  isRef,\r\n  isReference: isRef,\r\n  not,\r\n  notIncludes,\r\n  toBool,\r\n\r\n  deepFreeze,\r\n  key,\r\n  keyByVal: key,\r\n\r\n  // string\r\n  transformObjectKey,\r\n  toCamelcase,\r\n  toCamelKey: toCamelcase,\r\n  toSnakecase,\r\n  toSnakeKey: toSnakecase,\r\n  toPascalcase,\r\n  pascalCase,\r\n  isDatetimeString,\r\n\r\n  ap,\r\n  instanceOf,\r\n\r\n  ternary,\r\n  ifT,\r\n  ifF,\r\n\r\n  // array\r\n  removeByIndex,\r\n  removeByIdx: removeByIndex,\r\n  removeLast,\r\n  append,\r\n  prepend,\r\n\r\n  mapWithKey,\r\n  mapWithIdx: mapWithKey,\r\n  forEachWithKey,\r\n  forEachWithIdx: forEachWithKey,\r\n  reduceWithKey,\r\n  reduceWithIdx: reduceWithKey,\r\n  isFalsy,\r\n  isTruthy,\r\n\r\n  getOr\r\n};\r\n"],"names":["isPromise","x","fp","isFunction","get","promisify","a","args","cond","fn","Promise","resolve","reject","e","fnPromisify","identity","T","flatPromise","thenable","then","curry","otherwise","catch","_finally","finally","not","isNotEmpty","pipe","isEmpty","ternary","evaluator","trueHandler","falseHandler","executor","t","f","isTrue","isNil","instanceOf","pascalCase","camelCase","upperFirst","mapAsync","_ref","_asyncToGenerator","asyncMapper","collection","composer","flatMapDeep","_ref2","all","_x3","apply","this","arguments","_x","_x2","filterAsync","_ref3","asyncFilter","arr","_ref4","item","_x6","filter","equals","_x4","_x5","findAsync","_ref5","asyncFn","indexOf","idx","always","undefined","_x7","_x8","reduceAsync","initAcc","dest","initAccPromise","reduce","forEachAsync","_ref6","cb","loopResults","iterator","entries","push","_x9","_x10","key","v","find","k","val","head","deepFreeze","obj","Object","freeze","forOwn","isRef","isFrozen","transformObjectKey","transformFn","isObject","isArray","convertTo","o","acc","isPlainObject","map","transformedKey","has","Error","convertRecursively","toCamelcase","toSnakecase","snakeCase","toPascalcase","ap","curried","isNotNil","ifT","every","ifF","notIncludes","includes","notEquals","b","removeByIndex","cloned","cloneDeep","splice","toNumber","append","concat","prepend","array","value","mapWithKey","convert","cap","forEachWithKey","forEach","reduceWithKey","isVal","isBoolean","isNumber","isString","isFalsy","some","NaN","getOr","defaultValue","path","target","andThen","isJson","attempt","isError","JSON","parse","isNotEqual","isPrimitive","isReference","toBool","keyByVal","toCamelKey","toSnakeKey","isDatetimeString","str","isNaN","Date","removeByIdx","removeLast","nextA","pop","substring","size","mapWithIdx","forEachWithIdx","reduceWithIdx","isTruthy"],"mappings":"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"}